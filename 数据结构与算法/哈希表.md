# 哈希
0![image.png](https://cdn.nlark.com/yuque/0/2022/png/2976158/1647584408240-16d46048-72cf-472c-b4d3-3b143485d295.png)<br />

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2976158/1647584425911-e117c9f0-a7ba-49d5-999a-af2c68a4f8cf.png)



# 哈希表

数组存在的不足<br />如果基于内容去查找，性能非常低

哈希表：**可以直接将我们的名字作为索引，来提高我们的查询速度**。就是数组，Key-value的存数的数据结构，不同点在于哈希表它的key时经过一个哈希函数计算出来，我们称为关键码<br />以键值对的形式存储的数据结构，不同点是哈希表的键：是通过散列函数计算得出来的，关键码。每一个关键码对应一个值，<br />我们把这种以关键码-->值的形式存储数据的数组称为哈希表（散列表）<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/2976158/1647587932645-d548c29b-0591-4e38-b1ef-5b929415ba53.png)



重点：**有一个哈希函数，通过哈希函数就会把要存储的值能够映射到一个位置，这个位置就是它的下表或者是索引。**<br />**传一个字符串进来，就会把他映射成数组  **

数组里边：如果数组的下标相同，后面添加的就会覆盖前面的，这个叫覆盖<br />哈希表：冲突，冲撞，对于不同的要存储的数据经过哈希函数得到的索引有可能相同<br />解决方法：
### 开放地址法
#### 线性探测法：
**当在哈希表中插入某个数时，如果冲突发生的时候，他会以循环表的方式顺序查看表中下一个单元，直到找出一个空闲单元或查遍全表。**<br />若当前key与原来key产生相同的哈希地址，则当前key存在该地址之后没有存任何元素的地址中<br />key1：hash(key)+0<br />key2：hash(key)+1<br />key3：hash(key)+2<br />这样线性探测法可能使第 i 个散列地址的同义词存入第 i+1个散列地址，这样本应该存入第 i+1个散列地址的元素就会争夺第 i+2个散列地址的元素的地址。从而造成大量元素在相邻的散列地址上聚集起来，大大降低了查找效率。同时，也给删除操作带来了比较大的困难。<br />有冲突的时候，查询会从对应的位置向后查询，**直到查找到空间单元或者目标单元**<br />缺点：如果有索引连续的值，会出现聚集，会影响hash表的性能，每次查询/删除都会遍历更多的单元（连续的值没有空单元）

#### 二次探测
若当前key与原来key产生相同的哈希地址，则当前key存在该地址后偏移量为（1,2,3...）的二次方地址处<br />key1：hash(key)+0<br />key2：hash(key)+1^2<br />key3：hash(key)+2^2

### 链地址法
**数组储存的不是实际的值，存储的一个链表来存储实际数据**<br />链地址法也成为拉链法。其基本思路是：将所有具有相同哈希地址的而不同关键字的数据元素连接到同一个单链表中。如果选定的哈希表长度为m，则可将哈希表定义为一个有m个头指针组成的指针数组T[0..m-1]，凡是哈希地址为i的数据元素，均以节点的形式插入到T[i]为头指针的单链表中。并且新的元素插入到链表的前端，这不仅因为方便，还因为经常发生这样的事实：新近插入的元素最优可能不久又被访问。

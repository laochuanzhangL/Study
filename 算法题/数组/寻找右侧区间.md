![image.png](https://cdn.nlark.com/yuque/0/2022/png/2976158/1653142159599-3686d538-18a7-4524-aa5a-16748bf56517.png#clientId=u9cd0997e-5065-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=575&id=u3856de50&margin=%5Bobject%20Object%5D&name=image.png&originHeight=719&originWidth=935&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41407&status=done&style=none&taskId=u0a7ce3ff-21e5-454f-bb88-ff451d63683&title=&width=748)

# 自己解法
思路：硬来，每一个元素都遍历到，十分浪费资源
```javascript
/**
* @param {number[][]} intervals
* @return {number[]}
*/
var findRightInterval = function(intervals) {
  let result=[];
  let len=intervals.length;
  for(let i=0;i<len;i++){
    let temp={
      num:Infinity,
      index:-1
    }
    for(let j=0;j<len;j++){
      if(intervals[i][1]<=intervals[j][0])
      {
        if(temp.index===-1){
          temp.index=j
        }
        else{
          if(intervals[j][0]<intervals[temp.index][0]&&intervals[j][0]-intervals[i][1]>=0){
            temp.index=j
          }
        }
        
      }
    }
    result[i]=temp.index==-1?-1:temp.index
  }
  return result
};
```
# 官方解法：
先根据数组中起点的大小进行排序，再使用二分法，不用遍历所有元素

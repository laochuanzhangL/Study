
# 垃圾回收

       JavaScript为开发者卸下了这个 负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很 简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程 是周期性的，即垃圾回收程序每隔一定时间就会自动运行。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏 览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。


## 1）标记清理

        现在**最常用**的垃圾回收策略是标记清理。

        当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑 上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。

        给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。

        垃圾回收程序运行的时候，**会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存**。


## 2）引用计数

        另一种没那么常用的垃圾回收策略是引用计数（reference counting）。**其思路是对每个值都记录它被引用的次数。声明变量并给 它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一 个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办 法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序 下次运行的时候就会释放引用数为0的值的内存。**

       引用计数最早由Netscape Navigator 3.0采用，但很快就遇到了严重 的问题：循环引用。所谓循环引用，就是对象A有一个指针指向对象B，而对象B也引用了对象A。比如：

```javascript
function problem() {
  let objectA = new Object();
  let objectB = new Object();
  objectA.someOtherObject = objectB;
  objectB.anotherObject = objectA;
}
```

        在这个例子中， objectA 和 objectB 通过各自的属性相互引 用，意味着它们的引用数都是2。在标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，objectA 和 objectB 在函数结束后还会存在，**因为它们的引用数永远不会变成0**。如果函数被多次调用，**则会导致大量内存永远不会被释放**。为此，Netscape在4.0版放弃了引用计数，转而采用标记清理。事实上，引用计数策略的问题还不止于此。


## 3）性能

        垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的**时间调度**很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：**无论什么时候开始收集垃圾，都能让它尽快结束工作。**


## 4）内存管理

        在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过，JavaScript运行在一个内存管理与垃圾回收都很特殊的环境。分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。

       将内存占用量保持在一个较小的值可以让页面性能更好。**优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null ，从而释放其引用**。这也可以叫作**解除引用**。这个建议最适合**全局变量和全局对象的属性**。**局部变量在超出作用域后会被自动解除引用**，如下面的例子所示：

```javascript
function create(name){
let local = new Object();
local.name = name;
return local;
}
let global = create("Nicholas");
// 解除global对值的引用
global = null;
```

      在上面的代码中，变量 global保存着 create() 函数调用返回的值。在 create() 内 部， local创建了一个对象并给它添加了一个name 属性。然后，local 作为函数值被返回，并被赋值给global 。 local在 create()执行完 成超出上下文后会自动被解除引用，不需要显式处理。但 global是一个全局变量，应该在不再需要时手动解除其引用，最后一行就是这么做的。

      不过要注意，解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。


### 内存泄漏


#### 1）循环引用

这个没什么好说的，上面已经介绍了。

需要强调的一点就是，一旦数据不再使用，最好通过将其值设为 null 来释放其引用，这个方法就是上述的解除引用。


#### 2）**无意的全局变量**

```javascript
function foo(arg) {
    bar = "";
}
 
foo();
```

        上面的代码就无意中声明了一个全局变量，会得到 window 的引用，bar 实际上是 window.bar，它的**作用域在 window 上**，所以 foo 函数执行结束后，bar 也不会被内存收回。

         另外一种无意的全局变量的情况是：

```javascript
function foo() {
    this.bar = "";
}
```

        在 foo 函数中，this 指的是 window，犯的错误跟上面类似。


#### 3）**被遗忘的计时器和回调函数**

```javascript
let someResource = getData();
setInterval(() => {
    const node = document.getElementById('Node');
    if(node) {
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);
```

         上面的例子中，我们每隔一秒就将得到的数据放入到文档节点中去。**但在 setInterval 没有结束前，回调函数里的变量以及回调函数本身都无法被回收**。那什么才叫结束呢？就是调用了 clearInterval。**如果回调函数内没有做什么事情，并且也没有被 clear 掉的话**，就会造成内存泄漏。不仅如此，**如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收**。上面的例子中，someResource 就没法被回收。同样的，setTiemout 也会有同样的问题。所以，当不需要 interval 或者 timeout 时，最好调用 clearInterval 或者 clearTimeout。


## 5）优化技巧




#### 1）声明优化

      通过 **const 和 let 声明**有助于改进垃圾回收的过程。因为 const 和 let 都以块为作用域，所以相比于使用 var ，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在 块作用域比函数作用域更早终止的情况下，这就有可能发生。


#### 2）解除引用

     优化内存的一个最好的衡量方式就是只保留程序运行时需要的数据，对于已经使用的或者不需要的数据，应该将其值设为 null，这上面说过，叫“解除引用”。需要注意的是，解除一个值的引用不代表垃圾回收器会立即将这段内存回收，这样做的目的是让垃圾回收器在下一个回收周期到来时知道这段内存需要回收。

     在内存泄漏部分，我们讨论了无意的全局变量会带来无法回收的内存垃圾。但有些时候，我们会有意识地声明一些全局变量，这个时候需要注意，如果声明的变量占用大量的内存，那么在使用完后将变量声明为 null会有益垃圾回收。


# 进程和线程

**线程是最小的执行单元，进程是最小的资源管理单元**<br />进程是大哥，线程是小弟（进程管理着线程）<br />当软件运行后会开始一个进程，例如QQ，而QQ的运行有很多小功能组成，每一个小功能就是一个线程


# js单线程

**JS是单线程与其的作用有关**<br />js的主要作用：**完成与用户交互，以及DOM操作**

如果JS不是单线程：<br />一个线程操作一个DOM结点，而另一个线程删除了这个结点，就会造成冲突

所以JS会永远是单线程

H5, web worker标准，允许JS创建多个线程，但是子线程完全受主线程控制，而且子线程不可以操作DOM

js：单线程，同一个时间只能做一件事。<br />单线程：所以的任务需要排队，前一个任务结束了才能执行下一个任务。<br />如果前一个任务耗时很长，发起请求网络很慢，后面的任务就要一直等着。<br />为了解决上述问题：<br />IO的时候，主线程不去管IO，挂起处于等待中的任务，先执行排在后面的仍无，等待IO设备返回了结果，再回过头把挂起等待的任务继续执行下去<br />于是所有的任务就分为了：同步任务，异步任务

**同步任务：**<br />在主线程上排队执行的任务，只有前一个任务执行完毕以后，才能够去执行下一个任务。<br />同步会阻塞后面的代码

**异步任务：**<br />不进入主线程，而进入“任务队列”，**只有“任务队列”通知了主线程，某个异步任务可以执行了，这个任务才会被执行**

1. **所有的代码都在主线程执行，形成一个执行栈**
1. **主线程以外，还存在着一个任务队列（task queue），只要有了异步代码，就在“任务队列”放置一个事件**
1. **一旦执行栈所有的同步任务执行完毕之后，系统就会去读取“任务队列”，对应的异步任务，就会结束等待状态，进入执行栈，开始执行**

主线程不断重复上面的三个步骤<br />**任务队列：保存所有异步的代码 内部分为微任务和宏任务**

**主线程：同步任务->微任务->宏任务**
```javascript
//进入执行栈
console.log(1);
//进入任务队列 等到同步任务执行完毕
setTimeout(()=>{
	console.log(2);
},50)

setTimeout(()=>{
	console.log(3);
},0) //在同步任务执行结束后立即执行，并不是等待0秒

console.log(4);

最后输出：1432
```

**最先执行的是：同步代码，执行完毕以后，立即出栈，让出主线程**<br />**主线程去读取任务队列，队列遵循的原则是先进先出，但是，有个条件，触发条件相同的会遵循先进先出，**<br />**如果触发条件不同，则优先执行到达触发条件的代码，等待0秒是主线程一有空就立即执行**

**事件循环：主线程执行完毕去读取任务队列里面的任务的过程(EventLoop)**

**任务队列：内部存在两个队列，一个是宏任务队列，一个是微任务队列**
```javascript
setTimeout(()=>{
	console.log("setTimeout");
},0)

const promise=new Promise((resolve,rjt)=>{
	console("promise")
  resolve()
 
}).then(()=>{
	console("then")
})

输出：promise then setTimeout

因为then是微任务，setTimeout是宏任务
```
